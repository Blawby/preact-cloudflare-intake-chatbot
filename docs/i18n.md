# Internationalization Guide

This document explains the i18n foundations added in the `i18n-foundations` branch and how contributors can extend language coverage page by page.

## Current Stack

- **Library**: [`i18next`](https://www.i18next.com/) with [`react-i18next`](https://react.i18next.com/) via `preact/compat`
- **Supported locales**: English (`en`, default), Spanish (`es`), French (`fr`), German (`de`), Chinese/Simplified (`zh`), Japanese (`ja`), Vietnamese (`vi`)
- **Namespaces**: `common`, `settings`, `auth`, `profile`, `pricing`
- **Entry point**: `src/i18n/index.ts` (initialisation, locale helpers, dynamic loading)
- **Locale assets**: `src/locales/<locale>/<namespace>.json`
- **Validation**: `npm run lint:i18n` – ensures every locale has the same keys as the base (`en`)

## Provider & Runtime

`src/index.tsx` wraps the app with `I18nextProvider` and a `Suspense` loader. `initI18n()` ensures:

1. English resources ship in the initial bundle for SSR/hydration.
2. Additional locales load on demand through dynamic imports.
3. The active locale persists in `localStorage` (`blawby_locale`) and falls back to system detection when set to auto.

Helper exports from `src/i18n/index.ts`:

- `DEFAULT_LOCALE`, `SUPPORTED_LOCALES`
- `setLocale(locale: string)` – load resources (if necessary) and switch language.
- `detectBestLocale()` – returns the best effort from `navigator.language`.

## Adding Strings

1. Determine the namespace (`common`, `settings`, `auth`, …). When in doubt: use feature-based namespaces (e.g. `chat`, `pricing`) to keep files small.
2. Add the English key/value to `src/locales/en/<namespace>.json`.
3. Propagate the key to every other locale file. Use the English phrase as a placeholder if you do not have a translation yet.
4. Replace hard-coded text in the component with `const { t } = useTranslation('<namespace>');`.
5. Run `npm run lint:i18n` before pushing.

### Key Naming

```text
<namespace>.<feature>.<element>.<state>
```

Examples used in the initial migration:

- `settings:general.theme.options.dark`
- `settings:help.sections.helpCenter.description`

Camel-case keys are avoided to keep JSON grep-friendly.

## Sample Flow: Settings → Help / General

- `HelpPage.tsx` now pulls copy from `settings.help.*` keys, including aria labels.
- `GeneralPage.tsx` demonstrates
  - Using `common.language.*` helpers for dropdowns
  - Calling `setLocale()` when the interface language changes
  - Showing toast notifications with translated titles/bodies

Use these as references for future migrations (e.g. `AccountPage`, `PricingModal`).

## Locale Validation Script

`scripts/check-i18n.mjs` flattens every JSON file and compares keys against English. The script is intentionally strict so missing translations are caught during CI.

```bash
npm run lint:i18n
```

## Adding a New Locale

1. Duplicate `src/locales/en` → `src/locales/<new-locale>`.
2. Translate each namespace file.
3. Append the locale to `SUPPORTED_LOCALES` in `src/i18n/index.ts` and any UI select lists (e.g. `GeneralPage`).
4. Update docs/tests (see below) to cover the new language.

## Testing Tips

- **Smoke script**: run `npm run test:i18n` to ensure key translations differ between English and Spanish after changes.
- **Unit**: create component-level tests using `I18nextProvider` and the new `RootTestProviders` pattern (to be added) so strings render as expected.
- **Manual**: change languages via Settings → General, reload the app, and ensure the selection persists.
- **Automation**: extend Playwright flows to switch locales and snapshot key screens.

## Follow-up Backlog (suggested issues)

1. **Component migrations** – iterate through UI surfaces (chat, modals, pricing, auth, etc.). Track progress per namespace/route.
2. **Worker / API responses** – decide whether to internationalize server messages or expose machine-readable codes for client-side translation.
3. **Prompt localisation** – create per-locale AI prompts or copy decks (requires product/legal review).
4. **Translation workflow** – integrate a localisation platform (Crowdin, Lokalise, Tolgee…) and wire CI to validate imports.
5. **Manifest & SEO** – translate `SEOHead`, `index.html`, sitemap, and PWA manifest metadata.
6. **Testing harness** – introduce helper utilities (e.g. `renderWithI18n`) and update existing tests to avoid relying on raw English strings.

Keep discussions and PRs scoped per feature to make reviews approachable for new contributors.

## Auth Namespace Implementation

The `auth` namespace (`src/locales/<locale>/auth.json`) contains translations for authentication flows:

### Structure
- `signin.*` - Sign-in form labels, placeholders, and messages
- `signup.*` - Sign-up form labels, placeholders, and messages  
- `messages.*` - Success/status messages (account created, signed in, etc.)
- `errors.*` - Error messages (validation, network, etc.)
- `navigation.*` - Navigation elements (back buttons, etc.)
- `defaults.*` - Default user names and fallback values

### Error Handling Patterns

When implementing auth flows, follow these patterns:

1. **Validation Errors**: Use `t('errors.required')`, `t('errors.invalidEmail')`, etc.
2. **Success Messages**: Use `t('messages.accountCreated')`, `t('messages.signedIn')`, etc.
3. **Default Values**: Use `t('defaults.demoUserName')` for fallback user names
4. **Form Labels**: Use `t('signin.email')` vs `t('signup.email')` for context-specific labels

### Example Usage

```tsx
const { t } = useTranslation('auth');

// Form labels
<label>{t(isSignUp ? 'signup.email' : 'signin.email')}</label>

// Error messages
setError(t('errors.passwordsDoNotMatch'));

// Success messages
setMessage(t('messages.accountCreated'));

// Default values
name: formData.name || t('defaults.demoUserName')
```

### Mock Data Considerations

When creating mock users or default data, avoid hardcoded English strings:

- ✅ Use `t('defaults.demoUserName')` instead of `'Demo User'`
- ✅ Use `t('defaults.googleUserName')` instead of `'Google User'`
- ✅ Use translated error messages instead of hardcoded English strings

This ensures that even mock data respects the user's selected language.

## Profile Namespace Implementation

The `profile` namespace (`src/locales/<locale>/profile.json`) contains translations for user profile flows:

### Structure
- `menu.*` - Profile menu items (settings, upgrade, help, sign in/out)
- `status.*` - Status messages (loading, signing out)
- `aria.*` - Accessibility labels for screen readers

### Key Patterns

#### Interpolation for Dynamic Values

When user data needs to be displayed in translations, use interpolation:

```tsx
const { t } = useTranslation('profile');

// With interpolation
aria-label={t('aria.userProfile', { name: user.name })}
// Renders: "User profile for Steve Chris" (English)
// Renders: "Perfil de usuario para Steve Chris" (Spanish)
```

In the translation file:
```json
{
  "aria": {
    "userProfile": "User profile for {{name}}"
  }
}
```

#### Context-Specific Labels

Profile flows often need multiple versions of the same action:

```json
{
  "menu": {
    "upgrade": "Upgrade plan",
    "upgradeShort": "Upgrade"
  }
}
```

Use the full version in dropdowns/menus where space permits, and the short version for inline buttons.

#### Mock Data Services

Profile-related mock data services (like `mockUserDataService`) may contain hardcoded English strings. This is acceptable for:

- Test user names (e.g., `'Steve Chris'`, `'Demo User'`)
- Development-only bio text
- Mock organization names

These are not user-facing UI strings and don't need translation. However, any strings that appear in the actual UI (toast messages, button labels, form validation) must use translation keys.

### Example Usage

```tsx
const { t } = useTranslation(['profile', 'common']);

// Menu items
{t('profile:menu.signIn')}
{t('profile:menu.settings')}
{t('profile:menu.upgrade')}
{t('profile:menu.signOut')}

// Accessibility
title={isCollapsed ? t('profile:menu.signIn') : undefined}
aria-label={t('profile:aria.signInButton')}

// With user data interpolation
aria-label={t('profile:aria.userProfile', { name: user.name })}
```

### Future: Toast Messages in Profile Flows

When implementing toast notifications in profile flows (e.g., sign-out confirmation, profile update success), follow these patterns:

1. **Add keys to profile.json**:
```json
{
  "toasts": {
    "signOutSuccess": "Successfully signed out",
    "profileUpdateSuccess": "Profile updated successfully"
  }
}
```

2. **Use in toast calls**:
```tsx
showToast({
  title: t('profile:toasts.signOutSuccess'),
  type: 'success'
});
```

## Pricing Namespace Implementation

The `pricing` namespace (`src/locales/<locale>/pricing.json`) contains translations for pricing, billing, and subscription flows:

### Structure
- `plans.*` - Plan names, descriptions, and button text (free, plus, business)
- `features.*` - Feature names, descriptions, and tier-specific text
- `limitations.*` - Plan-specific limitations
- `benefits.*` - Plan-specific benefits
- `modal.*` - Pricing modal UI strings (title, tabs, labels)
- `billing.*` - Billing period labels and currency strings
- `comparison.*` - Feature comparison table labels

### Currency Formatting

All price displays use `Intl.NumberFormat` for locale-aware currency formatting via the `currencyFormatter` utility:

```tsx
import { formatCurrency } from '../utils/currencyFormatter';
import { useTranslation } from 'react-i18next';

const { i18n } = useTranslation();

// Format currency with locale awareness
const formattedPrice = formatCurrency(
  plan.priceAmount,  // 20
  plan.currency,     // 'USD'
  i18n.language      // 'es'
);
// Returns locale-appropriate format:
// en-US: "$20.00"
// es-ES: "20,00 US$" 
// fr-FR: "20,00 $US"
// de-DE: "20,00 $"
// Note: Exact formatting depends on Intl.NumberFormat for each locale
```

#### Currency Formatter Functions

**`formatCurrency(amount, currency, locale)`**
- Formats a price with currency symbol
- Automatically handles decimal places (0 for whole numbers, 2 for decimals)
- Falls back to `en-US` if locale is unsupported

**`getCurrencySymbol(currency, locale)`**
- Extracts just the currency symbol for a given currency and locale
- Useful for custom display patterns

**`formatPrice(amount, locale)`**
- Formats a number without currency symbol
- Useful for displaying amounts in tables or lists

**`buildPriceDisplay(amount, currency, billingPeriod, locale, t)`**
- Complete price string with currency and billing period
- Example: `"$20 USD / month"` or `"20 € EUR / mois"` (French)

### Translation Key Patterns

All pricing data in `mockPricingData.ts` uses translation keys instead of hardcoded strings:

```typescript
// ❌ Before (hardcoded)
const PRICING_PLANS = [{
  id: 'free',
  name: 'Free',
  description: 'Legal AI assistance for everyday needs',
  buttonText: 'Your current plan'
}];

// ✅ After (translation keys)
const PRICING_PLANS = [{
  id: 'free',
  name: 'pricing:plans.free.name',
  description: 'pricing:plans.free.description',
  buttonText: 'pricing:plans.free.buttonText'
}];
```

### Example Usage

```tsx
const { t, i18n } = useTranslation('pricing');

// Plan names and descriptions
<h3>{t('plans.plus.name')}</h3>
<p>{t('plans.plus.description')}</p>

// Feature text with tier-specific variants
<span>{t('features.aiAccess.text.free')}</span>
<span>{t('features.aiAccess.text.plus')}</span>
<span>{t('features.aiAccess.text.business')}</span>

// Modal UI strings
<h1>{t('modal.title')}</h1>
<button>{t('modal.tabs.personal')}</button>
<button>{t('modal.tabs.business')}</button>

// Currency formatting
const price = formatCurrency(20, 'USD', i18n.language) + ' ' + 
              'USD' + ' ' + 
              t('billing.perMonth');
// Examples (format varies by locale via Intl.NumberFormat):
// en-US: "$20.00 USD / month"
// es-ES: "20,00 US$ USD / mes"
// fr-FR: "20,00 $US USD / mois"
// Note: Actual output depends on browser's Intl.NumberFormat implementation
```

### Translating Plans Dynamically

When displaying pricing plans from `mockPricingDataService`, translate them at render time:

```tsx
const { t, i18n } = useTranslation('pricing');
const rawPlans = mockPricingDataService.getPricingPlans();

const translatedPlans = rawPlans.map(plan => ({
  ...plan,
  name: t(plan.name),
  description: t(plan.description),
  buttonText: t(plan.buttonText),
  price: formatCurrency(plan.priceAmount, plan.currency, i18n.language) + ' ' +
         plan.currency.toUpperCase() + ' ' +
         t(`billing.per${plan.billingPeriod === 'month' ? 'Month' : 'Year'}`),
  features: plan.features.map(f => ({
    ...f,
    text: t(f.text),
    description: f.description ? t(f.description) : undefined
  })),
  benefits: plan.benefits?.map(b => t(b)),
  limitations: plan.limitations?.map(l => t(l))
}));
```

### Mock Data Service Considerations

The `mockPricingDataService` returns translation keys, not translated text. This ensures:

1. **Separation of concerns**: Data structure is separate from presentation
2. **Dynamic language switching**: Plans update immediately when locale changes
3. **Consistent formatting**: Currency and dates format according to user's locale
4. **Easy maintenance**: Update translations without touching data structures

### Culturally Appropriate Formatting

Each language receives culturally appropriate translations:

- **Date formats**: Handled automatically by `Intl.NumberFormat`
- **Currency position**: `$20` (English), `20 $` (French), `20€` (German)
- **Professional terminology**: Legal terms translated appropriately for each market
- **Formal vs informal**: Appropriate formality level for business software

### Testing Pricing Translations

```bash
# Validate all pricing translations exist
npm run lint:i18n

# Test i18n implementation
npm run test:i18n

# Manual QA checklist:
# 1. Change language in settings
# 2. Open pricing modal
# 3. Verify plan names are translated
# 4. Verify feature descriptions are translated
# 5. Verify currency formats correctly (symbol position, separators)
# 6. Verify billing periods are translated
# 7. Verify button text is translated
```
